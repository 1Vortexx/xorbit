<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>X-ORBIT Music Player</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #121212;
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }

        /* Login Screen */
        .login-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background: linear-gradient(135deg, #1db954 0%, #191414 100%);
        }

        .login-container {
            text-align: center;
            padding: 40px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }

        .login-container h1 {
            font-size: 48px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #1db954, #1ed760);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .login-container p {
            color: #b3b3b3;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .qr-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            display: inline-block;
            margin-bottom: 20px;
        }

        .qr-instructions {
            color: #b3b3b3;
            font-size: 14px;
            margin-top: 20px;
            max-width: 400px;
            line-height: 1.6;
        }

        .qr-instructions ol {
            text-align: left;
            margin-top: 10px;
        }

        .loading-text {
            color: #1db954;
            font-size: 16px;
            margin-top: 20px;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .login-btn {
            background: #1db954;
            color: white;
            border: none;
            padding: 15px 50px;
            border-radius: 500px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .login-btn:hover {
            background: #1ed760;
            transform: scale(1.05);
        }

        /* Main Player */
        .player-container {
            display: none;
            height: 100vh;
            flex-direction: row;
        }

        /* Sidebar */
        .sidebar {
            width: 250px;
            background: #000;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #282828;
        }

        .sidebar-logo {
            padding: 20px;
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(135deg, #1db954, #1ed760);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .nav-menu {
            flex: 1;
            padding: 10px 0;
            overflow-y: auto;
        }

        .nav-item {
            padding: 12px 20px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 15px;
            color: #b3b3b3;
            font-size: 14px;
        }

        .nav-item:hover {
            color: #fff;
            background: #282828;
        }

        .nav-item.active {
            color: #fff;
            background: #282828;
        }

        .nav-item i {
            width: 20px;
            text-align: center;
        }

        .nav-divider {
            height: 1px;
            background: #282828;
            margin: 10px 20px;
        }

        .playlist-item {
            padding: 8px 20px;
            cursor: pointer;
            transition: all 0.3s;
            color: #b3b3b3;
            font-size: 13px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .playlist-item:hover {
            color: #fff;
        }

        /* Main Content Area */
        .content-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* Top Bar */
        .top-bar {
            background: #000;
            padding: 15px 30px;
            display: flex;
            align-items: center;
            gap: 20px;
            border-bottom: 1px solid #282828;
        }

        .search-container {
            flex: 1;
            max-width: 500px;
        }

        .search-input {
            width: 100%;
            padding: 12px 20px;
            border-radius: 500px;
            border: none;
            background: #242424;
            color: white;
            font-size: 14px;
            outline: none;
        }

        .search-input:focus {
            background: #2a2a2a;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #b3b3b3;
        }

        .logout-btn {
            background: transparent;
            color: #b3b3b3;
            border: 1px solid #535353;
            padding: 8px 20px;
            border-radius: 500px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .logout-btn:hover {
            border-color: #fff;
            color: #fff;
            transform: scale(1.05);
        }

        /* Main Content */
        .main-content {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            background: #121212;
        }

        .section-title {
            font-size: 24px;
            margin-bottom: 20px;
            font-weight: bold;
        }

        /* Search Results */
        .search-results {
            display: none;
        }

        .track-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .track-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .track-item:hover {
            background: #2a2a2a;
        }

        .track-album-art {
            width: 50px;
            height: 50px;
            border-radius: 4px;
            margin-right: 15px;
            object-fit: cover;
        }

        .track-info {
            flex: 1;
        }

        .track-name {
            font-size: 16px;
            margin-bottom: 5px;
        }

        .track-artist {
            font-size: 14px;
            color: #b3b3b3;
        }

        .track-duration {
            color: #b3b3b3;
            font-size: 14px;
        }

        /* Now Playing */
        .now-playing-section {
            text-align: center;
            padding: 40px;
        }

        .now-playing-art {
            width: 300px;
            height: 300px;
            border-radius: 8px;
            margin: 0 auto 30px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
        }

        .now-playing-title {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .now-playing-artist {
            font-size: 18px;
            color: #b3b3b3;
            margin-bottom: 30px;
        }

        /* Player Controls */
        .player-controls {
            background: #181818;
            padding: 20px 30px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-top: 1px solid #282828;
        }

        .current-track {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
            min-width: 0;
        }

        .current-track-art {
            width: 60px;
            height: 60px;
            border-radius: 4px;
            object-fit: cover;
        }

        .current-track-info {
            min-width: 0;
        }

        .current-track-name {
            font-size: 14px;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .current-track-artist {
            font-size: 12px;
            color: #b3b3b3;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .control-buttons {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            flex: 1;
        }

        .control-btn {
            background: transparent;
            border: none;
            color: #b3b3b3;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 16px;
            padding: 8px;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .control-btn:hover {
            color: #fff;
            transform: scale(1.1);
        }

        .control-btn i {
            font-style: normal;
        }

        .fa-shuffle::before { content: "üîÄ"; }
        .fa-step-backward::before { content: "‚èÆ"; }
        .fa-play::before { content: "‚ñ∂"; }
        .fa-pause::before { content: "‚è∏"; }
        .fa-step-forward::before { content: "‚è≠"; }
        .fa-repeat::before { content: "üîÅ"; }
        .fa-repeat-1::before { content: "üîÇ"; }
        .fa-volume-up::before { content: "üîä"; }
        .fa-search::before { content: "üîç"; }
        .fa-heart::before { content: "‚ù§"; }
        .fa-list::before { content: "üìã"; }

        .control-btn.active {
            color: #1db954;
        }

        .play-btn {
            background: #fff;
            color: #000;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            font-size: 18px;
        }

        .play-btn:hover {
            transform: scale(1.1);
            background: #fff;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
            justify-content: flex-end;
        }

        .volume-control i {
            color: #b3b3b3;
        }

        .volume-slider {
            width: 100px;
            cursor: pointer;
        }

        /* Progress Bar */
        .progress-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .progress-time {
            font-size: 12px;
            color: #b3b3b3;
            min-width: 40px;
        }

        .progress-bar {
            flex: 1;
            height: 4px;
            background: #404040;
            border-radius: 2px;
            cursor: pointer;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: #1db954;
            border-radius: 2px;
            transition: width 0.1s;
        }

        .progress-bar:hover .progress-fill {
            background: #1ed760;
        }

        /* Loading */
        .loading {
            text-align: center;
            padding: 40px;
            color: #b3b3b3;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
        }

        ::-webkit-scrollbar-track {
            background: #121212;
        }

        ::-webkit-scrollbar-thumb {
            background: #282828;
            border-radius: 6px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #3e3e3e;
        }
    </style>
</head>
<body>
    <!-- Login Screen -->
    <div class="login-screen" id="loginScreen">
        <div class="login-container">
            <h1>üéµ X-ORBIT Music</h1>
            <p>Powered by Spotify ‚Ä¢ Premium Required</p>
            
            <div id="qrSection" style="display: none;">
                <div class="qr-container">
                    <div id="qrcode"></div>
                </div>
                <div class="qr-instructions">
                    <strong>Scan with your phone:</strong>
                    <ol>
                        <li>Open camera app on your phone</li>
                        <li>Point at the QR code above</li>
                        <li>Tap the notification to open Spotify</li>
                        <li>Log in and authorize</li>
                    </ol>
                </div>
                <div class="loading-text">‚è≥ Waiting for authorization...</div>
            </div>
            
            <button class="login-btn" id="loginBtn" onclick="login()">Show QR Code</button>
        </div>
    </div>

    <!-- Main Player -->
    <div class="player-container" id="playerContainer">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-logo">üéµ X-ORBIT Music</div>
            
            <div class="nav-menu">
                <div class="nav-item active" onclick="showView('search')">
                    <i class="fas fa-search"></i>
                    <span>Search</span>
                </div>
                <div class="nav-item" onclick="showView('liked')">
                    <i class="fas fa-heart"></i>
                    <span>Liked Songs</span>
                </div>
                
                <div class="nav-divider"></div>
                
                <div class="nav-item" onclick="loadPlaylists()">
                    <i class="fas fa-list"></i>
                    <span>Your Playlists</span>
                </div>
                
                <div id="playlistsList"></div>
            </div>
        </div>

        <!-- Main Content Wrapper -->
        <div class="content-wrapper">
            <!-- Top Bar -->
            <div class="top-bar">
                <div class="search-container">
                    <input type="text" class="search-input" id="searchInput" placeholder="Search for songs, artists, or albums...">
                </div>
                <div class="user-info">
                    <span id="userName">User</span>
                    <button class="logout-btn" onclick="logout()">Logout</button>
                </div>
            </div>

            <!-- Main Content -->
            <div class="main-content" id="mainContent">
                <!-- Search View -->
                <div id="searchView">
                    <!-- Now Playing -->
                    <div class="now-playing-section" id="nowPlayingSection">
                        <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='300' height='300'%3E%3Crect fill='%23282828' width='300' height='300'/%3E%3Ctext fill='%23b3b3b3' font-family='Arial' font-size='20' x='50%25' y='50%25' text-anchor='middle' dominant-baseline='middle'%3ENo Track Playing%3C/text%3E%3C/svg%3E" class="now-playing-art" id="nowPlayingArt">
                        <div class="now-playing-title" id="nowPlayingTitle">No track playing</div>
                        <div class="now-playing-artist" id="nowPlayingArtist">Select a song to start</div>
                    </div>

                    <!-- Search Results -->
                    <div class="search-results" id="searchResults">
                        <h2 class="section-title">Search Results</h2>
                        <div class="track-list" id="trackList"></div>
                    </div>
                </div>

                <!-- Liked Songs View -->
                <div id="likedView" style="display: none;">
                    <h2 class="section-title">Liked Songs</h2>
                    <div class="track-list" id="likedTrackList"></div>
                </div>

                <!-- Playlist View -->
                <div id="playlistView" style="display: none;">
                    <h2 class="section-title" id="playlistTitle">Playlist</h2>
                    <div class="track-list" id="playlistTrackList"></div>
                </div>
            </div>

            <!-- Player Controls -->
            <div class="player-controls">
                <div class="current-track">
                    <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='60' height='60'%3E%3Crect fill='%23282828' width='60' height='60'/%3E%3Ctext fill='%23b3b3b3' font-family='Arial' font-size='24' x='50%25' y='50%25' text-anchor='middle' dominant-baseline='middle'%3E‚ô™%3C/text%3E%3C/svg%3E" class="current-track-art" id="currentTrackArt">
                    <div class="current-track-info">
                        <div class="current-track-name" id="currentTrackName">No track</div>
                        <div class="current-track-artist" id="currentTrackArtist">-</div>
                    </div>
                </div>

                <div style="flex: 1;">
                    <div class="control-buttons">
                        <button class="control-btn" id="shuffleBtn" onclick="toggleShuffle()" title="Shuffle">
                            <i class="fas fa-shuffle"></i>
                        </button>
                        <button class="control-btn" onclick="previousTrack()" title="Previous">
                            <i class="fas fa-step-backward"></i>
                        </button>
                        <button class="control-btn play-btn" id="playBtn" onclick="togglePlay()" title="Play/Pause">
                            <i class="fas fa-play"></i>
                        </button>
                        <button class="control-btn" onclick="nextTrack()" title="Next">
                            <i class="fas fa-step-forward"></i>
                        </button>
                        <button class="control-btn" id="repeatBtn" onclick="toggleRepeat()" title="Repeat">
                            <i class="fas fa-repeat"></i>
                        </button>
                    </div>
                    <div class="progress-container">
                        <span class="progress-time" id="currentTime">0:00</span>
                        <div class="progress-bar" id="progressBar" onclick="seekTrack(event)">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <span class="progress-time" id="totalTime">0:00</span>
                    </div>
                </div>

                <div class="volume-control">
                    <i class="fas fa-volume-up"></i>
                    <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="50">
                </div>
            </div>
        </div>
    </div>

    <script src="https://sdk.scdn.co/spotify-player.js"></script>
    <script>
        // Inline QR Code Generator (no external dependencies)
        const QRCode = (function() {
            function QRCode(element, options) {
                this.element = typeof element === 'string' ? document.getElementById(element) : element;
                this.options = options || {};
                if (this.options.text) {
                    this.makeCode(this.options.text);
                }
            }

            QRCode.prototype.makeCode = function(text) {
                this.element.innerHTML = '';
                const qr = qrcodegen.QrCode.encodeText(text, qrcodegen.QrCode.Ecc.MEDIUM);
                const size = this.options.width || 256;
                const cellSize = Math.floor(size / qr.size);
                const canvas = document.createElement('canvas');
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                // Draw QR code
                for (let y = 0; y < qr.size; y++) {
                    for (let x = 0; x < qr.size; x++) {
                        ctx.fillStyle = qr.getModule(x, y) ? '#000000' : '#ffffff';
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
                
                this.element.appendChild(canvas);
            };

            // QR Code generator core (minimal implementation)
            const qrcodegen = (function() {
                function QrCode(version, errorCorrectionLevel, dataCodewords, msk) {
                    this.version = version;
                    this.errorCorrectionLevel = errorCorrectionLevel;
                    this.modules = [];
                    this.isFunction = [];
                    const size = version * 4 + 17;
                    for (let i = 0; i < size; i++) {
                        this.modules.push(Array(size).fill(false));
                        this.isFunction.push(Array(size).fill(false));
                    }
                    this.drawFunctionPatterns();
                    const allCodewords = this.addEccAndInterleave(dataCodewords);
                    this.drawCodewords(allCodewords);
                    this.applyMask(msk);
                    this.drawFormatBits(msk);
                    this.size = size;
                }

                QrCode.encodeText = function(text, ecl) {
                    const segs = QrSegment.makeSegments(text);
                    return QrCode.encodeSegments(segs, ecl);
                };

                QrCode.encodeSegments = function(segs, ecl, minVersion, maxVersion, mask, boostEcl) {
                    minVersion = minVersion || 1;
                    maxVersion = maxVersion || 40;
                    for (let version = minVersion; ; version++) {
                        const dataCapacityBits = QrCode.getNumDataCodewords(version, ecl) * 8;
                        const usedBits = QrSegment.getTotalBits(segs, version);
                        if (usedBits <= dataCapacityBits) {
                            const bb = [];
                            for (const seg of segs) {
                                bb.push(seg.mode.modeBits >> 2 & 3);
                                bb.push(seg.mode.modeBits >> 0 & 3);
                                const ccbits = seg.mode.numCharCountBits(version);
                                for (let i = ccbits - 1; i >= 0; i--)
                                    bb.push(seg.numChars >>> i & 1);
                                for (const b of seg.getData())
                                    bb.push(b);
                            }
                            const dataCodewords = [];
                            while (dataCodewords.length * 8 < bb.length)
                                dataCodewords.push(0);
                            for (let i = 0; i < bb.length; i++)
                                dataCodewords[i >>> 3] |= bb[i] << (7 - (i & 7));
                            return new QrCode(version, ecl, dataCodewords, mask || 0);
                        }
                        if (version >= maxVersion)
                            throw new RangeError("Data too long");
                    }
                };

                QrCode.prototype.getModule = function(x, y) {
                    return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];
                };

                QrCode.prototype.drawFunctionPatterns = function() {
                    for (let i = 0; i < this.size; i++) {
                        this.setFunctionModule(6, i, i % 2 == 0);
                        this.setFunctionModule(i, 6, i % 2 == 0);
                    }
                    this.drawFinderPattern(3, 3);
                    this.drawFinderPattern(this.size - 4, 3);
                    this.drawFinderPattern(3, this.size - 4);
                };

                QrCode.prototype.drawFinderPattern = function(x, y) {
                    for (let dy = -4; dy <= 4; dy++) {
                        for (let dx = -4; dx <= 4; dx++) {
                            const dist = Math.max(Math.abs(dx), Math.abs(dy));
                            const xx = x + dx, yy = y + dy;
                            if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size)
                                this.setFunctionModule(xx, yy, dist != 2 && dist != 4);
                        }
                    }
                };

                QrCode.prototype.setFunctionModule = function(x, y, isDark) {
                    this.modules[y][x] = isDark;
                    this.isFunction[y][x] = true;
                };

                QrCode.prototype.addEccAndInterleave = function(data) {
                    const ver = this.version;
                    const ecl = this.errorCorrectionLevel;
                    const numBlocks = QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
                    const blockEccLen = QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];
                    const rawCodewords = Math.floor(QrCode.getNumRawDataModules(ver) / 8);
                    const numShortBlocks = numBlocks - rawCodewords % numBlocks;
                    const shortBlockLen = Math.floor(rawCodewords / numBlocks);
                    const result = [];
                    const rsDiv = QrCode.reedSolomonComputeDivisor(blockEccLen);
                    for (let i = 0, k = 0; i < numBlocks; i++) {
                        const datBlock = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
                        k += datBlock.length;
                        const eccBlock = QrCode.reedSolomonComputeRemainder(datBlock, rsDiv);
                        if (i < numShortBlocks)
                            datBlock.push(0);
                        result.push(datBlock.concat(eccBlock));
                    }
                    const interleaved = [];
                    for (let i = 0; i < result[0].length; i++) {
                        for (const block of result) {
                            if (i != shortBlockLen - blockEccLen || block.length != shortBlockLen)
                                interleaved.push(block[i]);
                        }
                    }
                    return interleaved;
                };

                QrCode.prototype.drawCodewords = function(data) {
                    let i = 0;
                    for (let right = this.size - 1; right >= 1; right -= 2) {
                        if (right == 6) right = 5;
                        for (let vert = 0; vert < this.size; vert++) {
                            for (let j = 0; j < 2; j++) {
                                const x = right - j;
                                const upward = ((right + 1) & 2) == 0;
                                const y = upward ? this.size - 1 - vert : vert;
                                if (!this.isFunction[y][x] && i < data.length * 8) {
                                    this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));
                                    i++;
                                }
                            }
                        }
                    }
                };

                QrCode.prototype.applyMask = function(msk) {
                    for (let y = 0; y < this.size; y++) {
                        for (let x = 0; x < this.size; x++) {
                            let invert;
                            switch (msk) {
                                case 0:  invert = (x + y) % 2 == 0;  break;
                                case 1:  invert = y % 2 == 0;  break;
                                case 2:  invert = x % 3 == 0;  break;
                                case 3:  invert = (x + y) % 3 == 0;  break;
                                case 4:  invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;  break;
                                case 5:  invert = x * y % 2 + x * y % 3 == 0;  break;
                                case 6:  invert = (x * y % 2 + x * y % 3) % 2 == 0;  break;
                                case 7:  invert = ((x + y) % 2 + x * y % 3) % 2 == 0;  break;
                                default:  throw new Error("Assertion error");
                            }
                            if (!this.isFunction[y][x] && invert)
                                this.modules[y][x] = !this.modules[y][x];
                        }
                    }
                };

                QrCode.prototype.drawFormatBits = function(msk) {
                    const data = this.errorCorrectionLevel.formatBits << 3 | msk;
                    let rem = data;
                    for (let i = 0; i < 10; i++)
                        rem = (rem << 1) ^ ((rem >>> 9) * 0x537);
                    const bits = (data << 10 | rem) ^ 0x5412;
                    for (let i = 0; i <= 5; i++)
                        this.setFunctionModule(8, i, getBit(bits, i));
                    this.setFunctionModule(8, 7, getBit(bits, 6));
                    this.setFunctionModule(8, 8, getBit(bits, 7));
                    this.setFunctionModule(7, 8, getBit(bits, 8));
                    for (let i = 9; i < 15; i++)
                        this.setFunctionModule(14 - i, 8, getBit(bits, i));
                    for (let i = 0; i < 8; i++)
                        this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));
                    for (let i = 8; i < 15; i++)
                        this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));
                    this.setFunctionModule(8, this.size - 8, true);
                };

                QrCode.getNumRawDataModules = function(ver) {
                    let result = (16 * ver + 128) * ver + 64;
                    if (ver >= 2) {
                        const numAlign = Math.floor(ver / 7) + 2;
                        result -= (25 * numAlign - 10) * numAlign - 55;
                        if (ver >= 7)
                            result -= 36;
                    }
                    return result;
                };

                QrCode.getNumDataCodewords = function(ver, ecl) {
                    return Math.floor(QrCode.getNumRawDataModules(ver) / 8) -
                        QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] *
                        QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
                };

                QrCode.reedSolomonComputeDivisor = function(degree) {
                    const result = [];
                    for (let i = 0; i < degree - 1; i++)
                        result.push(0);
                    result.push(1);
                    let root = 1;
                    for (let i = 0; i < degree; i++) {
                        for (let j = 0; j < result.length; j++) {
                            result[j] = QrCode.reedSolomonMultiply(result[j], root);
                            if (j + 1 < result.length)
                                result[j] ^= result[j + 1];
                        }
                        root = QrCode.reedSolomonMultiply(root, 0x02);
                    }
                    return result;
                };

                QrCode.reedSolomonComputeRemainder = function(data, divisor) {
                    const result = divisor.map(() => 0);
                    for (const b of data) {
                        const factor = b ^ result.shift();
                        result.push(0);
                        for (let i = 0; i < result.length; i++)
                            result[i] ^= QrCode.reedSolomonMultiply(divisor[i], factor);
                    }
                    return result;
                };

                QrCode.reedSolomonMultiply = function(x, y) {
                    let z = 0;
                    for (let i = 7; i >= 0; i--) {
                        z = (z << 1) ^ ((z >>> 7) * 0x11D);
                        z ^= ((y >>> i) & 1) * x;
                    }
                    return z;
                };

                QrCode.NUM_ERROR_CORRECTION_BLOCKS = [
                    [1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
                    [1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
                    [1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
                    [1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81],
                ];

                QrCode.ECC_CODEWORDS_PER_BLOCK = [
                    [7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
                    [10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
                    [13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
                    [17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
                ];

                function Ecc(ordinal, formatBits) {
                    this.ordinal = ordinal;
                    this.formatBits = formatBits;
                }

                QrCode.Ecc = {
                    LOW: new Ecc(0, 1),
                    MEDIUM: new Ecc(1, 0),
                    QUARTILE: new Ecc(2, 3),
                    HIGH: new Ecc(3, 2),
                };

                function QrSegment(mode, numChars, bitData) {
                    this.mode = mode;
                    this.numChars = numChars;
                    this.bitData = bitData;
                }

                QrSegment.makeSegments = function(text) {
                    return [QrSegment.makeBytes(QrSegment.toUtf8ByteArray(text))];
                };

                QrSegment.makeBytes = function(data) {
                    const bb = [];
                    for (const b of data) {
                        for (let i = 7; i >= 0; i--)
                            bb.push(b >>> i & 1);
                    }
                    return new QrSegment(QrSegment.Mode.BYTE, data.length, bb);
                };

                QrSegment.toUtf8ByteArray = function(str) {
                    str = encodeURI(str);
                    const result = [];
                    for (let i = 0; i < str.length; i++) {
                        if (str.charAt(i) != "%")
                            result.push(str.charCodeAt(i));
                        else {
                            result.push(parseInt(str.substr(i + 1, 2), 16));
                            i += 2;
                        }
                    }
                    return result;
                };

                QrSegment.getTotalBits = function(segs, version) {
                    let result = 0;
                    for (const seg of segs) {
                        const ccbits = seg.mode.numCharCountBits(version);
                        result += 4 + ccbits + seg.bitData.length;
                    }
                    return result;
                };

                QrSegment.prototype.getData = function() {
                    return this.bitData.slice();
                };

                function Mode(modeBits, charcounts) {
                    this.modeBits = modeBits;
                    this.numBitsCharCount = charcounts;
                }

                Mode.prototype.numCharCountBits = function(ver) {
                    return this.numBitsCharCount[Math.floor((ver + 7) / 17)];
                };

                QrSegment.Mode = {
                    NUMERIC: new Mode(0x1, [10, 12, 14]),
                    ALPHANUMERIC: new Mode(0x2, [9, 11, 13]),
                    BYTE: new Mode(0x4, [8, 16, 16]),
                    KANJI: new Mode(0x8, [8, 10, 12]),
                    ECI: new Mode(0x7, [0, 0, 0]),
                };

                function getBit(x, i) {
                    return ((x >>> i) & 1) != 0;
                }

                return {
                    QrCode: QrCode,
                    QrSegment: QrSegment,
                };
            })();

            return QRCode;
        })();
    </script>
    <script>
        const CLIENT_ID = '48dbdebd797842549795d880459bba50';
        const AUTH_SERVER = 'https://auth.xorbit.org';

        let player;
        let deviceId;
        let currentTrack = null;
        let accessToken = null;
        let shuffleState = false;
        let repeatState = 0; // 0 = off, 1 = context, 2 = track
        let pollInterval = null;

        // Login function with QR code
        async function login() {
            const loginBtn = document.getElementById('loginBtn');
            const qrSection = document.getElementById('qrSection');
            
            loginBtn.style.display = 'none';
            qrSection.style.display = 'block';

            try {
                // Request auth initiation
                const response = await fetch(`${AUTH_SERVER}/auth/initiate`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                const data = await response.json();
                const { sessionId, authUrl } = data;

                // Generate QR code
                document.getElementById('qrcode').innerHTML = '';
                new QRCode(document.getElementById('qrcode'), {
                    text: authUrl,
                    width: 256,
                    height: 256
                });

                // Start polling for authorization
                startPolling(sessionId);
            } catch (error) {
                console.error('Login initiation error:', error);
                alert('Failed to generate QR code. Please try again.');
                loginBtn.style.display = 'block';
                qrSection.style.display = 'none';
            }
        }

        // Poll for authorization
        function startPolling(sessionId) {
            let attempts = 0;
            const maxAttempts = 60; // 5 minutes (5 seconds * 60)

            pollInterval = setInterval(async () => {
                attempts++;

                if (attempts > maxAttempts) {
                    clearInterval(pollInterval);
                    alert('QR code expired. Please try again.');
                    window.location.reload();
                    return;
                }

                try {
                    const response = await fetch(`${AUTH_SERVER}/auth/poll/${sessionId}`);
                    const data = await response.json();

                    if (data.status === 'authorized') {
                        clearInterval(pollInterval);
                        
                        // Store tokens
                        localStorage.setItem('spotify_access_token', data.accessToken);
                        if (data.refreshToken) {
                            localStorage.setItem('spotify_refresh_token', data.refreshToken);
                        }

                        // Initialize player
                        accessToken = data.accessToken;
                        initializePlayer();
                    }
                } catch (error) {
                    console.error('Polling error:', error);
                }
            }, 5000); // Poll every 5 seconds
        }

        // Logout function
        function logout() {
            if (pollInterval) {
                clearInterval(pollInterval);
            }
            localStorage.removeItem('spotify_access_token');
            localStorage.removeItem('spotify_refresh_token');
            window.location.reload();
        }

        // Get access token from localStorage
        function getAccessToken() {
            return localStorage.getItem('spotify_access_token');
        }

        // Initialize player
        function initializePlayer() {
            // Show player
            document.getElementById('loginScreen').style.display = 'none';
            document.getElementById('playerContainer').style.display = 'flex';

            // Get user info
            fetch('https://api.spotify.com/v1/me', {
                headers: {
                    'Authorization': `Bearer ${accessToken}`
                }
            })
            .then(response => response.json())
            .then(data => {
                document.getElementById('userName').textContent = data.display_name;
            });

            // Initialize player
            player = new Spotify.Player({
                name: 'X-ORBIT Music Player',
                getOAuthToken: cb => { cb(accessToken); },
                volume: 0.5
            });

            // Error handling
            player.addListener('initialization_error', ({ message }) => {
                console.error('Failed to initialize', message);
            });

            player.addListener('authentication_error', ({ message }) => {
                console.error('Failed to authenticate', message);
                logout();
            });

            player.addListener('account_error', ({ message }) => {
                console.error('Failed to validate account', message);
                alert('Spotify Premium is required to use this player.');
            });

            player.addListener('playback_error', ({ message }) => {
                console.error('Failed to perform playback', message);
            });

            // Ready
            player.addListener('ready', ({ device_id }) => {
                console.log('Ready with Device ID', device_id);
                deviceId = device_id;
            });

            player.addListener('not_ready', ({ device_id }) => {
                console.log('Device ID has gone offline', device_id);
            });

            // Player state changed
            player.addListener('player_state_changed', state => {
                if (!state) return;

                currentTrack = state.track_window.current_track;
                updateNowPlaying(currentTrack);
                updatePlayerControls(state);
            });

            // Connect to player
            player.connect();
        }

        // Check for existing token on page load
        window.onSpotifyWebPlaybackSDKReady = () => {
            accessToken = getAccessToken();

            if (!accessToken) {
                document.getElementById('loginScreen').style.display = 'flex';
                return;
            }

            initializePlayer();
        };

        // Update now playing display
        function updateNowPlaying(track) {
            if (!track) return;

            document.getElementById('nowPlayingArt').src = track.album.images[0].url;
            document.getElementById('nowPlayingTitle').textContent = track.name;
            document.getElementById('nowPlayingArtist').textContent = track.artists.map(a => a.name).join(', ');

            document.getElementById('currentTrackArt').src = track.album.images[0].url;
            document.getElementById('currentTrackName').textContent = track.name;
            document.getElementById('currentTrackArtist').textContent = track.artists.map(a => a.name).join(', ');
        }

        // Update player controls
        function updatePlayerControls(state) {
            const playBtn = document.getElementById('playBtn');
            const playIcon = playBtn.querySelector('i');
            
            if (state.paused) {
                playIcon.className = 'fas fa-play';
            } else {
                playIcon.className = 'fas fa-pause';
            }

            // Update progress
            const position = state.position;
            const duration = state.duration;
            
            document.getElementById('currentTime').textContent = formatTime(position);
            document.getElementById('totalTime').textContent = formatTime(duration);
            
            const progress = (position / duration) * 100;
            document.getElementById('progressFill').style.width = progress + '%';

            // Update shuffle state
            if (state.shuffle !== undefined && state.shuffle !== shuffleState) {
                shuffleState = state.shuffle;
                document.getElementById('shuffleBtn').classList.toggle('active', shuffleState);
            }
            
            // Update repeat state
            if (state.repeat_mode !== undefined && state.repeat_mode !== repeatState) {
                repeatState = state.repeat_mode;
                
                const repeatBtn = document.getElementById('repeatBtn');
                const repeatIcon = repeatBtn.querySelector('i');
                
                if (repeatState === 0) {
                    repeatBtn.classList.remove('active');
                    repeatIcon.className = 'fas fa-repeat';
                } else if (repeatState === 1) {
                    repeatBtn.classList.add('active');
                    repeatIcon.className = 'fas fa-repeat';
                } else if (repeatState === 2) {
                    repeatBtn.classList.add('active');
                    repeatIcon.className = 'fas fa-repeat-1';
                }
            }
        }

        // Format time
        function formatTime(ms) {
            const seconds = Math.floor(ms / 1000);
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Toggle play/pause
        async function togglePlay() {
            try {
                const state = await player.getCurrentState();
                if (!state) {
                    console.error('No active device');
                    return;
                }
                
                if (state.paused) {
                    await player.resume();
                } else {
                    await player.pause();
                }
            } catch (error) {
                console.error('Toggle play error:', error);
            }
        }

        // Previous track
        async function previousTrack() {
            try {
                await player.previousTrack();
            } catch (error) {
                console.error('Previous track error:', error);
            }
        }

        // Next track
        async function nextTrack() {
            try {
                await player.nextTrack();
            } catch (error) {
                console.error('Next track error:', error);
            }
        }

        // Toggle shuffle
        async function toggleShuffle() {
            shuffleState = !shuffleState;
            
            try {
                await fetch(`https://api.spotify.com/v1/me/player/shuffle?state=${shuffleState}&device_id=${deviceId}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });
                
                document.getElementById('shuffleBtn').classList.toggle('active', shuffleState);
            } catch (error) {
                console.error('Shuffle error:', error);
            }
        }

        // Toggle repeat
        async function toggleRepeat() {
            // Cycle through: off (0) -> context (1) -> track (2) -> off (0)
            const nextState = (repeatState + 1) % 3;
            const repeatModes = ['off', 'context', 'track'];
            
            try {
                await fetch(`https://api.spotify.com/v1/me/player/repeat?state=${repeatModes[nextState]}&device_id=${deviceId}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });
                
                // Update the state
                repeatState = nextState;
                
                const repeatBtn = document.getElementById('repeatBtn');
                const repeatIcon = repeatBtn.querySelector('i');
                
                // Update button appearance based on state
                if (repeatState === 0) {
                    // Off - button not active, regular repeat icon
                    repeatBtn.classList.remove('active');
                    repeatIcon.className = 'fas fa-repeat';
                } else if (repeatState === 1) {
                    // Repeat context - button active, regular repeat icon
                    repeatBtn.classList.add('active');
                    repeatIcon.className = 'fas fa-repeat';
                } else if (repeatState === 2) {
                    // Repeat one - button active, repeat-1 icon
                    repeatBtn.classList.add('active');
                    repeatIcon.className = 'fas fa-repeat-1';
                }
            } catch (error) {
                console.error('Repeat error:', error);
            }
        }

        // Seek track
        function seekTrack(event) {
            player.getCurrentState().then(state => {
                if (!state) return;

                const rect = event.currentTarget.getBoundingClientRect();
                const percent = (event.clientX - rect.left) / rect.width;
                const position = Math.floor(percent * state.duration);
                
                player.seek(position);
            });
        }

        // Volume control
        document.getElementById('volumeSlider').addEventListener('input', (e) => {
            player.setVolume(e.target.value / 100);
        });

        // Search functionality
        let searchTimeout;
        document.getElementById('searchInput').addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            const query = e.target.value.trim();

            if (!query) {
                document.getElementById('searchResults').style.display = 'none';
                document.getElementById('nowPlayingSection').style.display = 'block';
                return;
            }

            searchTimeout = setTimeout(() => {
                searchTracks(query);
            }, 500);
        });

        // Search tracks
        function searchTracks(query) {
            fetch(`https://api.spotify.com/v1/search?q=${encodeURIComponent(query)}&type=track&limit=20`, {
                headers: {
                    'Authorization': `Bearer ${accessToken}`
                }
            })
            .then(response => response.json())
            .then(data => {
                displaySearchResults(data.tracks.items);
            })
            .catch(error => {
                console.error('Search error:', error);
            });
        }

        // Display search results
        function displaySearchResults(tracks) {
            const trackList = document.getElementById('trackList');
            trackList.innerHTML = '';

            document.getElementById('nowPlayingSection').style.display = 'none';
            document.getElementById('searchResults').style.display = 'block';

            tracks.forEach(track => {
                const trackItem = document.createElement('div');
                trackItem.className = 'track-item';
                trackItem.onclick = () => playTrack(track.uri);

                trackItem.innerHTML = `
                    <img src="${track.album.images[2]?.url || track.album.images[0]?.url}" class="track-album-art">
                    <div class="track-info">
                        <div class="track-name">${track.name}</div>
                        <div class="track-artist">${track.artists.map(a => a.name).join(', ')}</div>
                    </div>
                    <div class="track-duration">${formatTime(track.duration_ms)}</div>
                `;

                trackList.appendChild(trackItem);
            });
        }

        // Play track
        async function playTrack(uri) {
            try {
                await fetch(`https://api.spotify.com/v1/me/player/play?device_id=${deviceId}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        uris: [uri]
                    })
                });
                
                // Show now playing after a brief delay (only for search view)
                setTimeout(() => {
                    if (document.getElementById('searchView').style.display !== 'none') {
                        document.getElementById('searchResults').style.display = 'none';
                        document.getElementById('nowPlayingSection').style.display = 'block';
                        document.getElementById('searchInput').value = '';
                    }
                }, 500);
            } catch (error) {
                console.error('Playback error:', error);
            }
        }

        // Update progress bar continuously
        setInterval(() => {
            player?.getCurrentState().then(state => {
                if (!state || state.paused) return;
                updatePlayerControls(state);
            });
        }, 1000);

        // View switching
        function showView(view) {
            // Update nav active state
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            event.target.closest('.nav-item').classList.add('active');

            // Hide all views
            document.getElementById('searchView').style.display = 'none';
            document.getElementById('likedView').style.display = 'none';
            document.getElementById('playlistView').style.display = 'none';

            // Show selected view
            if (view === 'search') {
                document.getElementById('searchView').style.display = 'block';
            } else if (view === 'liked') {
                document.getElementById('likedView').style.display = 'block';
                loadLikedSongs();
            }
        }

        // Load liked songs
        async function loadLikedSongs() {
            const likedTrackList = document.getElementById('likedTrackList');
            likedTrackList.innerHTML = '<div class="loading">Loading your liked songs...</div>';

            try {
                const response = await fetch('https://api.spotify.com/v1/me/tracks?limit=50', {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });

                if (!response.ok) {
                    if (response.status === 403) {
                        likedTrackList.innerHTML = '<div class="loading">Permission denied. Please log out and log back in to grant library access.</div>';
                        return;
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                likedTrackList.innerHTML = '';

                if (!data.items || data.items.length === 0) {
                    likedTrackList.innerHTML = '<div class="loading">No liked songs found</div>';
                    return;
                }

                data.items.forEach(item => {
                    const track = item.track;
                    const trackItem = document.createElement('div');
                    trackItem.className = 'track-item';
                    trackItem.onclick = () => playTrack(track.uri);

                    trackItem.innerHTML = `
                        <img src="${track.album.images[2]?.url || track.album.images[0]?.url}" class="track-album-art">
                        <div class="track-info">
                            <div class="track-name">${track.name}</div>
                            <div class="track-artist">${track.artists.map(a => a.name).join(', ')}</div>
                        </div>
                        <div class="track-duration">${formatTime(track.duration_ms)}</div>
                    `;

                    likedTrackList.appendChild(trackItem);
                });
            } catch (error) {
                console.error('Error loading liked songs:', error);
                likedTrackList.innerHTML = '<div class="loading">Error loading liked songs. Try logging out and back in.</div>';
            }
        }

        // Load user playlists
        async function loadPlaylists() {
            const playlistsList = document.getElementById('playlistsList');
            playlistsList.innerHTML = '<div style="padding: 10px 20px; color: #b3b3b3; font-size: 12px;">Loading...</div>';

            try {
                const response = await fetch('https://api.spotify.com/v1/me/playlists?limit=50', {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });

                if (!response.ok) {
                    if (response.status === 403) {
                        playlistsList.innerHTML = '<div style="padding: 10px 20px; color: #b3b3b3; font-size: 12px;">Permission denied</div>';
                        return;
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                playlistsList.innerHTML = '';

                if (!data.items || data.items.length === 0) {
                    playlistsList.innerHTML = '<div style="padding: 10px 20px; color: #b3b3b3; font-size: 12px;">No playlists found</div>';
                    return;
                }

                data.items.forEach(playlist => {
                    const playlistItem = document.createElement('div');
                    playlistItem.className = 'playlist-item';
                    playlistItem.textContent = playlist.name;
                    playlistItem.onclick = () => loadPlaylistTracks(playlist.id, playlist.name);
                    playlistsList.appendChild(playlistItem);
                });
            } catch (error) {
                console.error('Error loading playlists:', error);
                playlistsList.innerHTML = '<div style="padding: 10px 20px; color: #b3b3b3; font-size: 12px;">Error loading playlists</div>';
            }
        }

        // Load playlist tracks
        async function loadPlaylistTracks(playlistId, playlistName) {
            // Update nav active state
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });

            // Hide all views
            document.getElementById('searchView').style.display = 'none';
            document.getElementById('likedView').style.display = 'none';
            document.getElementById('playlistView').style.display = 'block';

            const playlistTitle = document.getElementById('playlistTitle');
            const playlistTrackList = document.getElementById('playlistTrackList');
            
            playlistTitle.textContent = playlistName;
            playlistTrackList.innerHTML = '<div class="loading">Loading playlist...</div>';

            try {
                const response = await fetch(`https://api.spotify.com/v1/playlists/${playlistId}/tracks`, {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });

                const data = await response.json();
                playlistTrackList.innerHTML = '';

                if (data.items.length === 0) {
                    playlistTrackList.innerHTML = '<div class="loading">This playlist is empty</div>';
                    return;
                }

                data.items.forEach(item => {
                    if (!item.track) return;
                    
                    const track = item.track;
                    const trackItem = document.createElement('div');
                    trackItem.className = 'track-item';
                    trackItem.onclick = () => playTrackInContext(track.uri, `spotify:playlist:${playlistId}`);

                    trackItem.innerHTML = `
                        <img src="${track.album.images[2]?.url || track.album.images[0]?.url}" class="track-album-art">
                        <div class="track-info">
                            <div class="track-name">${track.name}</div>
                            <div class="track-artist">${track.artists.map(a => a.name).join(', ')}</div>
                        </div>
                        <div class="track-duration">${formatTime(track.duration_ms)}</div>
                    `;

                    playlistTrackList.appendChild(trackItem);
                });
            } catch (error) {
                console.error('Error loading playlist tracks:', error);
                playlistTrackList.innerHTML = '<div class="loading">Error loading playlist</div>';
            }
        }

        // Play track in context (for playlists)
        function playTrackInContext(uri, contextUri) {
            fetch(`https://api.spotify.com/v1/me/player/play?device_id=${deviceId}`, {
                method: 'PUT',
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    context_uri: contextUri,
                    offset: { uri: uri }
                })
            })
            .catch(error => {
                console.error('Playback error:', error);
            });
        }
    </script>
</body>
</html>
